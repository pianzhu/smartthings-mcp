# å¤§æ¨¡å‹å·¥å…·è§„åˆ’ç­–ç•¥ä¸æ¶æ„è®¾è®¡

## æ ¸å¿ƒæŒ‘æˆ˜

å¤§æ¨¡å‹åœ¨ä½¿ç”¨å·¥å…·æ—¶é¢ä¸´çš„ä¸»è¦é—®é¢˜ï¼š

1. **å·¥å…·é€‰æ‹©å›°éš¾** - å¤šä¸ªå·¥å…·å¯èƒ½å®Œæˆç›¸åŒä»»åŠ¡ï¼Œå¦‚ä½•é€‰æ‹©æœ€ä¼˜è·¯å¾„ï¼Ÿ
2. **é¡ºåºè§„åˆ’** - å¤æ‚ä»»åŠ¡éœ€è¦å¤šæ­¥éª¤ï¼Œå¦‚ä½•è§„åˆ’æ‰§è¡Œé¡ºåºï¼Ÿ
3. **ä¸Šä¸‹æ–‡çˆ†ç‚¸** - æ¯æ¬¡å·¥å…·è°ƒç”¨éƒ½ä¼šå¢åŠ ä¸Šä¸‹æ–‡ï¼Œå¦‚ä½•æ§åˆ¶ï¼Ÿ
4. **é”™è¯¯æ¢å¤** - å·¥å…·è°ƒç”¨å¤±è´¥æ—¶å¦‚ä½•ä¼˜é›…å¤„ç†ï¼Ÿ

---

## ç³»ç»Ÿæ¶æ„è®¾è®¡

### ä¸‰å±‚æ¶æ„æ¨¡å‹

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Layer 1: Context Layer (Cached)                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ - System Prompt (å·¥ä½œåŸåˆ™ã€ç¦æ­¢è¡Œä¸º)           â”‚    â”‚
â”‚  â”‚ - Static Context (æˆ¿é—´åˆ—è¡¨ã€èƒ½åŠ›ç±»å‹)          â”‚    â”‚
â”‚  â”‚ - Tool Descriptions (å·¥å…·ä½¿ç”¨æŒ‡å—)             â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚  Token: ~2000 | Cache Hit Rate: 95%                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Layer 2: Planning Layer (Dynamic)                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ 1. Intent Recognition (æ„å›¾è¯†åˆ«)               â”‚    â”‚
â”‚  â”‚    - æ§åˆ¶ / æŸ¥è¯¢ / åˆ†æ                        â”‚    â”‚
â”‚  â”‚                                                 â”‚    â”‚
â”‚  â”‚ 2. Device Location (è®¾å¤‡å®šä½)                  â”‚    â”‚
â”‚  â”‚    - search_devices(query)                     â”‚    â”‚
â”‚  â”‚    - æˆ–ä½¿ç”¨ç¼“å­˜çš„ device_id                    â”‚    â”‚
â”‚  â”‚                                                 â”‚    â”‚
â”‚  â”‚ 3. Task Decomposition (ä»»åŠ¡åˆ†è§£)               â”‚    â”‚
â”‚  â”‚    - å•æ­¥ vs å¤šæ­¥                              â”‚    â”‚
â”‚  â”‚    - ä¸²è¡Œ vs å¹¶è¡Œ                              â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚  Token: ~500-1000                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Layer 3: Execution Layer (Transient)                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ 1. Pre-Execution (æ‰§è¡Œå‰éªŒè¯)                  â”‚    â”‚
â”‚  â”‚    - get_device_commands (å¯é€‰)                â”‚    â”‚
â”‚  â”‚    - get_device_status (æ¡ä»¶æ§åˆ¶æ—¶)            â”‚    â”‚
â”‚  â”‚                                                 â”‚    â”‚
â”‚  â”‚ 2. Execution (æ‰§è¡Œ)                             â”‚    â”‚
â”‚  â”‚    - execute_commands / batch_execute          â”‚    â”‚
â”‚  â”‚                                                 â”‚    â”‚
â”‚  â”‚ 3. Post-Execution (æ‰§è¡Œåç¡®è®¤)                 â”‚    â”‚
â”‚  â”‚    - éªŒè¯ç»“æœ                                   â”‚    â”‚
â”‚  â”‚    - ç®€åŒ–è¿”å›ä¿¡æ¯                               â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚  Token: ~500-1500 | Discarded after confirmation       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Prompt Engineering ç­–ç•¥

### 1. ç³»ç»Ÿæç¤ºè¯è®¾è®¡

åœ¨ `src/server.py` ä¸­æ·»åŠ ï¼š

```python
AGENT_SYSTEM_PROMPT = """
You are a smart home assistant with access to SmartThings devices.

ğŸ¯ CORE PRINCIPLES:

1. MINIMAL INFORMATION PRINCIPLE
   - NEVER call get_devices() without filters
   - ALWAYS use search_devices(query) to locate devices
   - ONLY query status when necessary

2. EFFICIENT WORKFLOW
   - Simple control: search_devices â†’ execute_commands
   - Conditional control: search_devices â†’ get_device_status â†’ (conditional) execute_commands
   - Data analysis: search_devices â†’ get_device_history

3. CONTEXT MANAGEMENT
   - Remember device IDs mentioned in conversation
   - Reuse IDs instead of re-searching
   - Clear detailed status after task completion

4. ERROR PREVENTION
   - Use get_device_commands before executing unknown commands
   - Validate parameters before execution
   - Provide clear error messages to users

âŒ PROHIBITED BEHAVIORS:

- Do NOT guess command parameters
- Do NOT repeatedly query the same device status
- Do NOT return complete device lists to users
- Do NOT use get_devices() for exploration (use get_context_summary instead)

ğŸ“‹ TOOL SELECTION GUIDE:

Starting a conversation?
  â†’ get_context_summary()

User mentions a device/room?
  â†’ search_devices(query)

Need to control a device?
  â†’ Already have device_id? â†’ execute_commands()
  â†’ Don't know device_id? â†’ search_devices() â†’ execute_commands()

Need historical data?
  â†’ search_devices() â†’ get_device_history()

Uncertain about commands?
  â†’ get_device_commands(device_id, capability)

ğŸ”„ MULTI-TURN OPTIMIZATION:

Turn 1: User: "å®¢å…çš„ç¯åœ¨å“ªï¼Ÿ"
  â†’ search_devices("å®¢å… ç¯") â†’ Return device info
  â†’ REMEMBER: device_id = "abc123"

Turn 2: User: "æŠŠå®ƒæ‰“å¼€"
  â†’ USE CACHED: device_id = "abc123"
  â†’ execute_commands(device_id, ...)
  â†’ DO NOT re-search

Turn 3: User: "ç°åœ¨çŠ¶æ€å¦‚ä½•ï¼Ÿ"
  â†’ USE CACHED: device_id = "abc123"
  â†’ get_device_status(device_id)
"""

# åœ¨ FastMCP åˆå§‹åŒ–æ—¶æ³¨å…¥
mcp = FastMCP("SmartThings", port=8001)
# å¦‚æœ FastMCP æ”¯æŒç³»ç»Ÿæç¤ºï¼Œæ·»åŠ ï¼š
# mcp.set_system_prompt(AGENT_SYSTEM_PROMPT)
```

### 2. å·¥å…·æè¿°å¢å¼º

æ¯ä¸ªå·¥å…·çš„ `description` å¿…é¡»åŒ…å«ï¼š

```python
@mcp.tool(description="""
[FUNCTION]: Clear one-line description

[WHEN TO USE]:
- Scenario 1
- Scenario 2

[DO NOT USE]:
- Anti-pattern 1
- Anti-pattern 2

[EXAMPLE]:
Input: "Turn on living room light"
Flow: search_devices("living room light") â†’ execute_commands(...)

[OUTPUT FORMAT]:
Brief description of return value structure
""")
def tool_name(...):
    pass
```

**å®é™…ç¤ºä¾‹**ï¼š

```python
@mcp.tool(description="""
[FUNCTION]: Search devices by natural language query

[WHEN TO USE]:
- User mentions room + device type (e.g., "å®¢å…çš„ç¯", "å§å®¤ç©ºè°ƒ")
- First time encountering a device in conversation
- Need to find device without knowing ID

[DO NOT USE]:
- When device_id is already known from previous turns
- For "list all devices" requests (use get_context_summary instead)
- When user asks for statistics (use get_context_summary)

[EXAMPLE]:
User: "æ‰“å¼€å®¢å…çš„ç¯"
Step 1: search_devices("å®¢å… ç¯") â†’ Returns device_id
Step 2: execute_commands(device_id, [Command("main", "switch", "on")])

[OUTPUT FORMAT]:
List of {id, name, room, type, fullId}
Maximum 5 results, sorted by relevance
""")
def search_devices(query: str, limit: int = 5) -> List[dict]:
    pass
```

---

## å†³ç­–æ ‘è®¾è®¡

### ç”¨æˆ·æ„å›¾åˆ†ç±»

```python
# ä¼ªä»£ç ï¼šAI å†…éƒ¨å†³ç­–é€»è¾‘
def classify_intent(user_input: str) -> Intent:
    """
    CONTROL: "æ‰“å¼€å®¢å…çš„ç¯", "å…³é—­ç©ºè°ƒ"
    QUERY: "å®¢å…çš„æ¸©åº¦æ˜¯å¤šå°‘ï¼Ÿ", "ç¯ç°åœ¨æ˜¯å¼€çš„å—ï¼Ÿ"
    ANALYSIS: "è¿‡å»ä¸€å‘¨çš„å¹³å‡æ¸©åº¦", "ä»Šå¤©ç”¨äº†å¤šå°‘ç”µï¼Ÿ"
    DISCOVERY: "æˆ‘æœ‰å“ªäº›è®¾å¤‡ï¼Ÿ", "å®¢å…æœ‰ä»€ä¹ˆï¼Ÿ"
    """
    pass

def plan_workflow(intent: Intent, user_input: str) -> List[ToolCall]:
    if intent == Intent.CONTROL:
        return plan_control(user_input)
    elif intent == Intent.QUERY:
        return plan_query(user_input)
    elif intent == Intent.ANALYSIS:
        return plan_analysis(user_input)
    elif intent == Intent.DISCOVERY:
        return plan_discovery(user_input)
```

### æ§åˆ¶æ„å›¾å·¥ä½œæµ

```python
def plan_control(user_input: str) -> List[ToolCall]:
    """
    Example: "å¦‚æœå®¢å…æ¸©åº¦è¶…è¿‡ 26 åº¦ï¼Œæ‰“å¼€ç©ºè°ƒ"
    """
    # 1. è§£ææ¡ä»¶
    has_condition = detect_condition(user_input)  # "å¦‚æœ...é‚£ä¹ˆ..."

    if has_condition:
        # æ¡ä»¶æ§åˆ¶æµç¨‹
        return [
            ToolCall("search_devices", query="å®¢å… æ¸©åº¦"),
            ToolCall("get_device_status", device_id="<from_step1>"),
            # [AI å†…éƒ¨è¯„ä¼°æ¡ä»¶]
            ToolCall("search_devices", query="å®¢å… ç©ºè°ƒ"),
            ToolCall("execute_commands", device_id="<from_step3>", commands=[...])
        ]
    else:
        # ç®€å•æ§åˆ¶æµç¨‹
        return [
            ToolCall("search_devices", query="<extracted_query>"),
            ToolCall("execute_commands", device_id="<from_step1>", commands=[...])
        ]
```

### æŸ¥è¯¢æ„å›¾å·¥ä½œæµ

```python
def plan_query(user_input: str) -> List[ToolCall]:
    """
    Example: "å®¢å…çš„ç¯ç°åœ¨æ˜¯å¼€çš„å—ï¼Ÿ"
    """
    # æ£€æŸ¥æ˜¯å¦æœ‰ç¼“å­˜çš„ device_id
    device_id = check_conversation_history(user_input)

    if device_id:
        return [
            ToolCall("get_device_status", device_id=device_id)
        ]
    else:
        return [
            ToolCall("search_devices", query="<extracted_query>"),
            ToolCall("get_device_status", device_id="<from_step1>")
        ]
```

---

## ä¸Šä¸‹æ–‡æ„ŸçŸ¥è§„åˆ’

### Short-Term Memoryï¼ˆçŸ­æœŸè®°å¿†ï¼‰

AI åº”åœ¨å¯¹è¯ä¸­ç»´æŠ¤ï¼š

```python
# æ¦‚å¿µæ¨¡å‹ï¼ˆAI å†…éƒ¨çŠ¶æ€ï¼‰
conversation_context = {
    "mentioned_devices": {
        "living_room_light": {
            "device_id": "abc123...",
            "last_mentioned_turn": 2,
            "last_status": {"switch": "on"}
        }
    },
    "current_room": "living_room",  # æ¨æ–­çš„å½“å‰ä¸Šä¸‹æ–‡
    "pending_actions": []
}
```

**ä½¿ç”¨ç¤ºä¾‹**ï¼š

```
Turn 1:
User: "å®¢å…çš„ç¯åœ¨å“ªé‡Œï¼Ÿ"
AI: search_devices("å®¢å… ç¯")
    â†’ Store: mentioned_devices["living_room_light"] = {device_id: "abc123"}
Response: "æ‰¾åˆ°å®¢å…å¸é¡¶ç¯ (ID: abc123)"

Turn 2:
User: "æŠŠå®ƒæ‰“å¼€"
AI: Resolve "å®ƒ" â†’ living_room_light (device_id: abc123)
    â†’ execute_commands(abc123, [Command("main", "switch", "on")])
    â†’ NO need to search again!
Response: "å·²æ‰“å¼€å®¢å…å¸é¡¶ç¯"

Turn 3:
User: "ç°åœ¨çŠ¶æ€å¦‚ä½•ï¼Ÿ"
AI: Resolve context â†’ living_room_light
    â†’ get_device_status(abc123)
Response: "å®¢å…å¸é¡¶ç¯å½“å‰çŠ¶æ€ï¼šå¼€å¯"
```

### Long-Term Memoryï¼ˆé•¿æœŸè®°å¿†ï¼‰

è·¨å¯¹è¯ session çš„ä¼˜åŒ–ï¼ˆå¯é€‰ï¼‰ï¼š

```python
# å¦‚æœ MCP æ”¯æŒæŒä¹…åŒ–çŠ¶æ€
persistent_context = {
    "user_preferences": {
        "default_room": "living_room",
        "common_devices": ["living_room_light", "bedroom_ac"]
    },
    "frequent_commands": [
        {"device": "living_room_light", "command": "on", "count": 15},
        {"device": "bedroom_ac", "command": "setTemperature", "count": 8}
    ]
}
```

---

## å¹¶è¡Œä¸ä¸²è¡Œæ‰§è¡Œç­–ç•¥

### å¹¶è¡Œæ‰§è¡Œåœºæ™¯

```python
# User: "å‘Šè¯‰æˆ‘å®¢å…çš„æ¸©åº¦å’Œæ¹¿åº¦"

# âœ… æ­£ç¡®ï¼šå¹¶è¡ŒæŸ¥è¯¢
parallel_calls = [
    ToolCall("search_devices", query="å®¢å… æ¸©åº¦"),  # Call 1
    ToolCall("search_devices", query="å®¢å… æ¹¿åº¦")   # Call 2
]
# ç„¶åå¹¶è¡Œè·å–çŠ¶æ€
parallel_status = [
    ToolCall("get_device_status", device_id="temp_sensor_id"),
    ToolCall("get_device_status", device_id="humidity_sensor_id")
]

# âŒ é”™è¯¯ï¼šä¸²è¡Œæ‰§è¡Œï¼ˆæµªè´¹æ—¶é—´ï¼‰
sequential_calls = [
    ToolCall("search_devices", query="å®¢å… æ¸©åº¦"),
    # ç­‰å¾…...
    ToolCall("get_device_status", device_id="..."),
    # ç­‰å¾…...
    ToolCall("search_devices", query="å®¢å… æ¹¿åº¦"),
    # ç­‰å¾…...
    ToolCall("get_device_status", device_id="...")
]
```

### ä¸²è¡Œæ‰§è¡Œåœºæ™¯

```python
# User: "å¦‚æœå®¢å…æ¸©åº¦è¶…è¿‡ 26 åº¦ï¼Œæ‰“å¼€ç©ºè°ƒ"

# âœ… å¿…é¡»ä¸²è¡Œï¼šå› ä¸ºæœ‰ä¾èµ–å…³ç³»
sequential_calls = [
    ToolCall("search_devices", query="å®¢å… æ¸©åº¦"),
    ToolCall("get_device_status", device_id="<from_step1>"),
    # AI è¯„ä¼°æ¡ä»¶ï¼štemperature > 26?
    # å¦‚æœä¸ºçœŸï¼Œç»§ç»­ï¼š
    ToolCall("search_devices", query="å®¢å… ç©ºè°ƒ"),
    ToolCall("execute_commands", device_id="<from_step3>", commands=[...])
]
```

---

## é”™è¯¯å¤„ç†ä¸æ¢å¤

### ä¼˜é›…é™çº§ç­–ç•¥

```python
# Workflow with error handling
def execute_with_fallback(primary_plan, fallback_plan):
    try:
        result = execute(primary_plan)
        return result
    except DeviceNotFoundError:
        # Fallback: æ‰©å¤§æœç´¢èŒƒå›´
        return execute(fallback_plan)
    except CommandNotSupportedError:
        # Fallback: æŸ¥è¯¢æ”¯æŒçš„å‘½ä»¤
        commands = get_device_commands(device_id, capability)
        return retry_with_valid_command(commands)
    except Exception as e:
        return user_friendly_error(e)
```

**å®é™…ç¤ºä¾‹**ï¼š

```
User: "æ‰“å¼€å®¢å…çš„ç”µè§†"
AI: search_devices("å®¢å… ç”µè§†")
    â†’ Result: [] (æ²¡æ‰¾åˆ°)

Fallback:
AI: search_devices("ç”µè§†")  # å»æ‰æˆ¿é—´é™åˆ¶
    â†’ Result: [{"name": "ä¸»å§ç”µè§†", ...}, {"name": "å®¢å… TV", ...}]
    â†’ å‘ç”¨æˆ·ç¡®è®¤ï¼š"æ²¡æ‰¾åˆ°'å®¢å…çš„ç”µè§†'ï¼Œä½†æ‰¾åˆ°äº†'å®¢å… TV'ï¼Œæ˜¯è¿™ä¸ªå—ï¼Ÿ"
```

---

## æ€§èƒ½ä¼˜åŒ–æŠ€å·§

### 1. å·¥å…·è°ƒç”¨æ‰¹å¤„ç†

```python
# âŒ ä½æ•ˆï¼šå¤šæ¬¡å•ç‹¬è°ƒç”¨
for device_id in device_ids:
    execute_commands(device_id, [Command("main", "switch", "off")])

# âœ… é«˜æ•ˆï¼šæ‰¹é‡è°ƒç”¨
batch_execute_commands([
    {"device_id": id1, "commands": [Command("main", "switch", "off")]},
    {"device_id": id2, "commands": [Command("main", "switch", "off")]},
    ...
])
```

### 2. ç»“æœç¼“å­˜

```python
# åœ¨ AI çš„å¯¹è¯ä¸Šä¸‹æ–‡ä¸­ç¼“å­˜
cache = {
    "device_status": {
        "abc123": {
            "value": {"switch": "on"},
            "timestamp": "2025-11-12T10:30:00",
            "ttl": 300  # 5 åˆ†é’Ÿæœ‰æ•ˆ
        }
    }
}

# æŸ¥è¯¢æ—¶å…ˆæ£€æŸ¥ç¼“å­˜
if cache["device_status"].get(device_id) and not expired:
    return cache["device_status"][device_id]
else:
    result = get_device_status(device_id)
    cache["device_status"][device_id] = result
    return result
```

### 3. é¢„æµ‹æ€§åŠ è½½

```python
# User: "å®¢å…çš„ç¯åœ¨å“ªé‡Œï¼Ÿ"
AI: search_devices("å®¢å… ç¯")
    â†’ Result: device_id = "abc123"

# AI é¢„æµ‹ï¼šç”¨æˆ·å¯èƒ½æ¥ä¸‹æ¥ä¼šæ§åˆ¶è¿™ä¸ªç¯
# å¯é€‰ï¼šé¢„åŠ è½½å‘½ä»¤ä¿¡æ¯
preload_cache = get_device_commands(device_id, "switch")
# è¿™æ ·ä¸‹ä¸€è½®å¯¹è¯å¯ä»¥ç«‹å³æ‰§è¡Œï¼Œæ— éœ€å†æŸ¥è¯¢
```

---

## å®æ–½æ£€æŸ¥æ¸…å•

åœ¨å®ç° Agent æ—¶ï¼Œç¡®ä¿ï¼š

- [ ] System Prompt åŒ…å«æ‰€æœ‰å·¥ä½œåŸåˆ™
- [ ] æ¯ä¸ªå·¥å…·æœ‰å®Œæ•´çš„ä½¿ç”¨æŒ‡å—ï¼ˆWHEN TO USE / DO NOT USEï¼‰
- [ ] å®ç°æ„å›¾è¯†åˆ«é€»è¾‘
- [ ] å®ç°è®¾å¤‡ ID ç¼“å­˜æœºåˆ¶
- [ ] æ”¯æŒå¹¶è¡Œå·¥å…·è°ƒç”¨ï¼ˆç‹¬ç«‹æ“ä½œï¼‰
- [ ] å®ç°é”™è¯¯å¤„ç†å’Œä¼˜é›…é™çº§
- [ ] æ·»åŠ  token æ¶ˆè€—ç›‘æ§
- [ ] ç¼–å†™å†³ç­–æ ‘å•å…ƒæµ‹è¯•

---

## ä¸‹ä¸€æ­¥

ğŸ‘‰ é˜…è¯» [03-test-cases.md](03-test-cases.md) äº†è§£å¦‚ä½•éªŒè¯ Agent çš„è§„åˆ’èƒ½åŠ›
